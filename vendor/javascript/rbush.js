// rbush@4.0.1 downloaded from https://ga.jspm.io/npm:rbush@4.0.1/index.js

import t from"quickselect";class RBush{constructor(t=9){this._maxEntries=Math.max(4,t);this._minEntries=Math.max(2,Math.ceil(this._maxEntries*.4));this.clear()}all(){return this._all(this.data,[])}search(t){let i=this.data;const e=[];if(!intersects(t,i))return e;const n=this.toBBox;const s=[];while(i){for(let h=0;h<i.children.length;h++){const a=i.children[h];const r=i.leaf?n(a):a;intersects(t,r)&&(i.leaf?e.push(a):contains(t,r)?this._all(a,e):s.push(a))}i=s.pop()}return e}collides(t){let i=this.data;if(!intersects(t,i))return false;const e=[];while(i){for(let n=0;n<i.children.length;n++){const s=i.children[n];const h=i.leaf?this.toBBox(s):s;if(intersects(t,h)){if(i.leaf||contains(t,h))return true;e.push(s)}}i=e.pop()}return false}load(t){if(!(t&&t.length))return this;if(t.length<this._minEntries){for(let i=0;i<t.length;i++)this.insert(t[i]);return this}let i=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===i.height)this._splitRoot(this.data,i);else{if(this.data.height<i.height){const t=this.data;this.data=i;i=t}this._insert(i,this.data.height-i.height-1,true)}else this.data=i;return this}insert(t){t&&this._insert(t,this.data.height-1);return this}clear(){this.data=createNode([]);return this}remove(t,i){if(!t)return this;let e=this.data;const n=this.toBBox(t);const s=[];const h=[];let a,r,o;while(e||s.length){if(!e){e=s.pop();r=s[s.length-1];a=h.pop();o=true}if(e.leaf){const n=findItem(t,e.children,i);if(n!==-1){e.children.splice(n,1);s.push(e);this._condense(s);return this}}if(o||e.leaf||!contains(e,n))if(r){a++;e=r.children[a];o=false}else e=null;else{s.push(e);h.push(a);a=0;r=e;e=e.children[0]}}return this}toBBox(t){return t}compareMinX(t,i){return t.minX-i.minX}compareMinY(t,i){return t.minY-i.minY}toJSON(){return this.data}fromJSON(t){this.data=t;return this}_all(t,i){const e=[];while(t){t.leaf?i.push(...t.children):e.push(...t.children);t=e.pop()}return i}_build(t,i,e,n){const s=e-i+1;let h=this._maxEntries;let a;if(s<=h){a=createNode(t.slice(i,e+1));calcBBox(a,this.toBBox);return a}if(!n){n=Math.ceil(Math.log(s)/Math.log(h));h=Math.ceil(s/Math.pow(h,n-1))}a=createNode([]);a.leaf=false;a.height=n;const r=Math.ceil(s/h);const o=r*Math.ceil(Math.sqrt(h));multiSelect(t,i,e,o,this.compareMinX);for(let s=i;s<=e;s+=o){const i=Math.min(s+o-1,e);multiSelect(t,s,i,r,this.compareMinY);for(let e=s;e<=i;e+=r){const s=Math.min(e+r-1,i);a.children.push(this._build(t,e,s,n-1))}}calcBBox(a,this.toBBox);return a}_chooseSubtree(t,i,e,n){while(true){n.push(i);if(i.leaf||n.length-1===e)break;let s=Infinity;let h=Infinity;let a;for(let e=0;e<i.children.length;e++){const n=i.children[e];const r=bboxArea(n);const o=enlargedArea(t,n)-r;if(o<h){h=o;s=r<s?r:s;a=n}else if(o===h&&r<s){s=r;a=n}}i=a||i.children[0]}return i}_insert(t,i,e){const n=e?t:this.toBBox(t);const s=[];const h=this._chooseSubtree(n,this.data,i,s);h.children.push(t);extend(h,n);while(i>=0){if(!(s[i].children.length>this._maxEntries))break;this._split(s,i);i--}this._adjustParentBBoxes(n,s,i)}_split(t,i){const e=t[i];const n=e.children.length;const s=this._minEntries;this._chooseSplitAxis(e,s,n);const h=this._chooseSplitIndex(e,s,n);const a=createNode(e.children.splice(h,e.children.length-h));a.height=e.height;a.leaf=e.leaf;calcBBox(e,this.toBBox);calcBBox(a,this.toBBox);i?t[i-1].children.push(a):this._splitRoot(e,a)}_splitRoot(t,i){this.data=createNode([t,i]);this.data.height=t.height+1;this.data.leaf=false;calcBBox(this.data,this.toBBox)}_chooseSplitIndex(t,i,e){let n;let s=Infinity;let h=Infinity;for(let a=i;a<=e-i;a++){const i=distBBox(t,0,a,this.toBBox);const r=distBBox(t,a,e,this.toBBox);const o=intersectionArea(i,r);const l=bboxArea(i)+bboxArea(r);if(o<s){s=o;n=a;h=l<h?l:h}else if(o===s&&l<h){h=l;n=a}}return n||e-i}_chooseSplitAxis(t,i,e){const n=t.leaf?this.compareMinX:compareNodeMinX;const s=t.leaf?this.compareMinY:compareNodeMinY;const h=this._allDistMargin(t,i,e,n);const a=this._allDistMargin(t,i,e,s);h<a&&t.children.sort(n)}_allDistMargin(t,i,e,n){t.children.sort(n);const s=this.toBBox;const h=distBBox(t,0,i,s);const a=distBBox(t,e-i,e,s);let r=bboxMargin(h)+bboxMargin(a);for(let n=i;n<e-i;n++){const i=t.children[n];extend(h,t.leaf?s(i):i);r+=bboxMargin(h)}for(let n=e-i-1;n>=i;n--){const i=t.children[n];extend(a,t.leaf?s(i):i);r+=bboxMargin(a)}return r}_adjustParentBBoxes(t,i,e){for(let n=e;n>=0;n--)extend(i[n],t)}_condense(t){for(let i,e=t.length-1;e>=0;e--)if(t[e].children.length===0)if(e>0){i=t[e-1].children;i.splice(i.indexOf(t[e]),1)}else this.clear();else calcBBox(t[e],this.toBBox)}}function findItem(t,i,e){if(!e)return i.indexOf(t);for(let n=0;n<i.length;n++)if(e(t,i[n]))return n;return-1}function calcBBox(t,i){distBBox(t,0,t.children.length,i,t)}function distBBox(t,i,e,n,s){s||(s=createNode(null));s.minX=Infinity;s.minY=Infinity;s.maxX=-Infinity;s.maxY=-Infinity;for(let h=i;h<e;h++){const i=t.children[h];extend(s,t.leaf?n(i):i)}return s}function extend(t,i){t.minX=Math.min(t.minX,i.minX);t.minY=Math.min(t.minY,i.minY);t.maxX=Math.max(t.maxX,i.maxX);t.maxY=Math.max(t.maxY,i.maxY);return t}function compareNodeMinX(t,i){return t.minX-i.minX}function compareNodeMinY(t,i){return t.minY-i.minY}function bboxArea(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function bboxMargin(t){return t.maxX-t.minX+(t.maxY-t.minY)}function enlargedArea(t,i){return(Math.max(i.maxX,t.maxX)-Math.min(i.minX,t.minX))*(Math.max(i.maxY,t.maxY)-Math.min(i.minY,t.minY))}function intersectionArea(t,i){const e=Math.max(t.minX,i.minX);const n=Math.max(t.minY,i.minY);const s=Math.min(t.maxX,i.maxX);const h=Math.min(t.maxY,i.maxY);return Math.max(0,s-e)*Math.max(0,h-n)}function contains(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function intersects(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function createNode(t){return{children:t,height:1,leaf:true,minX:Infinity,minY:Infinity,maxX:-Infinity,maxY:-Infinity}}function multiSelect(i,e,n,s,h){const a=[e,n];while(a.length){n=a.pop();e=a.pop();if(n-e<=s)continue;const r=e+Math.ceil((n-e)/s/2)*s;t(i,r,e,n,h);a.push(e,r,r,n)}}export{RBush as default};

